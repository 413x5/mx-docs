---
id: elrond-vs-dfinity
title: Elrond vs. Dfinity
---

Dfinity are using the EVM machine for Smart Contracts, dApps can be written in Solidity only. Elrond has own VM built using K-framework for which a GO backend has been created in-house. Elrond will support Solidity, IELE, WASM and possibly other languages, with formal verification of Smart Contracts.

Dfinity uses VRF - verifiable random function - with BLS signature scheme and threshold mechanism to resolve “last actor abort” problem. The setup of a threshold group for DKG is time consuming and requires all actors to be active during this setup phase. In order for Dfinity to create a new randomness number, it needs to run a consensus with a set of rounds and communication. Elrond’s proposes a simpler and secure variant for randomness source creation, using a separate “linked list” of randomness source, where the current random number depends only on the previous random number and the signature of the current leader. Using BLS single signature scheme (important feature: signing the same message with the same private key always produces the same result) the current leader signs the previous random number and broadcasts it. It is un-biasable, easily verifiable, un-predictable and safe. The threshold relay used by Dfinity is slightly corruptible.

Because of the usage of “probabilistic slot protocol” Dfinity might have a number of forks and a constant forks resolve mechanism. The fork choice rule is the “heaviest” blockchain from the accumulated weights. For Elrond, being a partially synchronous system where the random seed drives the selection of leader and consensus for each round, forks are highly unlikely as a single block producer is set for each round. In case of desynchronization, the desynchronized node reverts to the last final block and asks for the next block from the shard. There will be only one valid block built upon this and accepted by the shard, because the members of the consensus group can be calculated from the random seed.

One of the biggest differences is that Dfinity does not use sharding. A random beacon selects a different group for consensus and block proposed at every round, the produced block is sent to the notary, then the random beacon selects the next group. Every proposer has to build upon the heaviest chain he sees which had its last block notarized by the notarizer. It is hard to see how it can scale without sharding. Elrond uses an all level sharding method - sharding the transactions, the network and the state. This makes the job of validators easier, they do not have to hold all the state. Transactions are processed in parallel, and the messages of intra-shard, cross-shard and any other type of messages are sent only to interested parties.